#!/usr/bin/env node
/*
 * AI-ContextGen
 * Automatically generates a Markdown snapshot of your codebase,
 * respecting .gitignore and .ai-ignore, ALWAYS skipping .git directory, and skipping large/binary files.
 *
 * Usage:
 *   node AI-ContextGen.js --input ./folder --output snapshot.md
 */

const fs = require('fs');
const path = require('path');
const ignore = require('ignore');
const { Command } = require('commander');
const cliProgress = require('cli-progress');

const program = new Command();

program
  .option('-i, --input <folder>', 'Input folder to scan', '.')
  .option('-o, --output <filename>', 'Output markdown filename', '__aicontextgen.md')
  .description('Generate a Markdown snapshot of your project folder for AI context, respecting .gitignore, .ai-ignore and skipping large/binary files.')
  .parse(process.argv);

// Show help if no args given
if (process.argv.length <= 2) {
  program.help();
}

const options = program.opts();
const START_DIR = path.resolve(options.input);
const OUTPUT_FILENAME = options.output;
const MAX_SIZE = 1024 * 1024; // 1MB

const SKIP_EXTENSIONS = [
  '.png', '.jpg', '.jpeg', '.gif', '.svg',
  '.ico', '.exe', '.dll', '.zip', '.tar', '.gz',
  '.mp4', '.mp3', '.ogg', '.mov', '.pdf', '.webp',
  '.woff', '.woff2', '.ttf', '.eot', '.otf'
];

// Always ignore .git directory and the output file
function getIgnoreFilter(baseDir) {
  const ig = ignore();
  const gitignorePath = path.join(baseDir, '.gitignore');
  if (fs.existsSync(gitignorePath)) {
    const content = fs.readFileSync(gitignorePath, 'utf8');
    ig.add(content.split(/\r?\n/));
  }
  const aiIgnorePath = path.join(baseDir, '.ai-ignore');
  if (fs.existsSync(aiIgnorePath)) {
    const content = fs.readFileSync(aiIgnorePath, 'utf8');
    ig.add(content.split(/\r?\n/));
  }
  ig.add('.git/'); // <-- Always ignore .git directory
  ig.add(OUTPUT_FILENAME);
  return ig;
}

// Recursively list files with ignore filter, using a progress bar
function listFiles(dir, base, ig, bar) {
  let results = [];
  const entries = fs.readdirSync(dir, { withFileTypes: true });
  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name);
    const relPath = path.relative(base, fullPath);
    if (ig.ignores(relPath.replace(/\\/g, '/'))) {
      bar.increment();
      continue;
    }
    if (entry.isDirectory()) {
      results = results.concat(listFiles(fullPath, base, ig, bar));
    } else {
      results.push(relPath);
      bar.increment();
    }
  }
  return results;
}

function filesToMarkdown(files, bar) {
  let md = `# AI-ContextGen Snapshot\n\n`;
  md += `> Generated by AI-ContextGen. Below is the full project context.\n\n`;

  for (const file of files) {
    md += `---\n\n`;
    md += `## \`${file}\`\n\n`;

    const filePath = path.join(START_DIR, file);
    const ext = path.extname(file).toLowerCase();
    let stats;
    try {
      stats = fs.statSync(filePath);
    } catch {
      md += `*(Unable to access file)*\n\n`;
      bar.increment();
      continue;
    }

    if (stats.size > MAX_SIZE) {
      md += `*(Skipped: file too large - ${(stats.size / 1024).toFixed(1)} KB)*\n\n`;
      bar.increment();
      continue;
    }
    if (SKIP_EXTENSIONS.includes(ext)) {
      md += `*(Skipped: extension \`${ext}\` not supported)*\n\n`;
      bar.increment();
      continue;
    }

    try {
      const content = fs.readFileSync(filePath, 'utf8');
      const lang = ext.slice(1) || 'txt';
      md += `\`\`\`${lang}\n${content}\n\`\`\`\n\n`;
    } catch {
      md += `*(Unable to read file as text)*\n\n`;
    }
    bar.increment();
  }

  md += `---\n`;
  return md;
}

(async function main() {
  try {
    if (!fs.existsSync(START_DIR) || !fs.statSync(START_DIR).isDirectory()) {
      console.error(`Error: Input folder does not exist or is not a directory: ${START_DIR}`);
      process.exit(1);
    }

    const ig = getIgnoreFilter(START_DIR);

    // First, count total entries to process for progress bar
    let totalCount = 0;
    function countEntries(dir) {
      const entries = fs.readdirSync(dir, { withFileTypes: true });
      for (const entry of entries) {
        const fullPath = path.join(dir, entry.name);
        const relPath = path.relative(START_DIR, fullPath);
        if (ig.ignores(relPath.replace(/\\/g, '/'))) continue;
        if (entry.isDirectory()) {
          countEntries(fullPath);
        } else {
          totalCount++;
        }
      }
    }
    countEntries(START_DIR);

    console.log(`Scanning files in ${START_DIR} (skipping per .gitignore, .ai-ignore, .git/, and config)...`);
    const barList = new cliProgress.SingleBar({}, cliProgress.Presets.shades_classic);
    barList.start(totalCount, 0);
    const files = listFiles(START_DIR, START_DIR, ig, barList);
    barList.stop();

    console.log(`\nGenerating markdown output for ${files.length} files...`);
    const barRead = new cliProgress.SingleBar({}, cliProgress.Presets.shades_classic);
    barRead.start(files.length, 0);
    const markdown = filesToMarkdown(files, barRead);
    barRead.stop();

    fs.writeFileSync(path.join(START_DIR, OUTPUT_FILENAME), markdown, 'utf8');
    console.log(`\nAI-ContextGen: Snapshot saved to ${path.join(START_DIR, OUTPUT_FILENAME)}`);

  } catch (err) {
    console.error('Fatal error:', err);
    process.exit(1);
  }
})();
